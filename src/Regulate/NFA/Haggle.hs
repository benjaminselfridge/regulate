{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE MonadComprehensions #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeFamilies #-}

-- | A module providing a simple implementation of NFAs in terms of @haggle@
-- graphs.
module Regulate.NFA.Haggle
   ( NFA, graph, alphabet, startState, finalStates
   , mkNFA
   -- * Generating strings
   , generate
   , generate'
   , generate1
   , generateAll
   -- * NFA combinators
   , join
   , nfaMap
   ) where

import Control.Monad (when, void)
import Control.Monad.ST
import Data.Foldable (forM_)
import Data.Graph.Haggle
import Data.Graph.Haggle.Algorithms.DFS
import Data.Map (Map)
import qualified Data.Map as Map
import Data.Maybe (fromJust, catMaybes)
import Data.Sequence (Seq)
import qualified Data.Sequence as Seq
import Data.Set (Set)
import qualified Data.Set as Set
import Data.STRef

-- | An @NFA@ over an alphabet @sigma@ is just a directed graph with labels from
-- @sigma@, along with a designated start state and a set of designated final
-- states.
--
-- The vertices of the graph correspond to the states, and the labeled edges are
-- transitions.
data NFA nl sigma = NFA { graph :: LabeledGraph BiDigraph nl sigma
                        , alphabet :: Set sigma
                        , startState :: Vertex
                        , finalStates :: Set Vertex
                        }

reduceGraph :: Vertex
            -- ^ start state
            -> Set Vertex
            -- ^ final states
            -> LabeledMGraph MBiDigraph nl sigma (ST s)
            -- ^ The graph
            -> ST s ( LabeledMGraph MBiDigraph nl sigma (ST s)
                    , Map Vertex Vertex
                    )
reduceGraph start finals gOld = do
  g' <- freeze gOld
  let reachables = Set.fromList (dfs g' [start])
      finishables = Set.fromList (rdfs g' (Set.toList finals))
      keepStates = reachables `Set.intersection` finishables

  gNew <- newLabeledGraph newMBiDigraph

  -- add all vertices, noting how the old ones map to new ones
  vertexMapRef <- newSTRef Map.empty
  forM_ keepStates $ \v' -> do
    v <- addLabeledVertex gNew (fromJust $ vertexLabel g' v')
    modifySTRef vertexMapRef (Map.insert v' v)

  vertexMap <- readSTRef vertexMapRef
  -- add all the needed edges
  forM_ keepStates $ \v' -> do
    let vSrc = fromJust $ Map.lookup v' vertexMap
    forM_ (outEdges g' v') $ \e' -> do
      let vDest = fromJust $ Map.lookup (edgeDest e') vertexMap
      when (edgeDest e' `Set.member` keepStates) $
        void $ addLabeledEdge gNew vSrc vDest (fromJust $ edgeLabel g' e')

  return (gNew, vertexMap)

mkNFA :: (Ord sigma)
      => LabeledGraph BiDigraph nl sigma
      -> Vertex
      -> Set Vertex
      -> NFA nl sigma
mkNFA g s finals = NFA g (Set.fromList (fromJust . edgeLabel g <$> edges g)) s finals

nfaMap :: (Ord tau)
       => (nl -> nl')
       -> (sigma -> tau)
       -> NFA nl sigma
       -> NFA nl' tau
nfaMap f g nfa = runST $ do
  g' <- newLabeledGraph newMBiDigraph
  vertexMapRef <- newSTRef Map.empty -- map from old vertices to new vertices
  startStateRef <- newSTRef Nothing
  finalStatesRef <- newSTRef Set.empty

  forM_ (vertices (graph nfa)) $ \v -> do
    v' <- addLabeledVertex g' (f . fromJust $ vertexLabel (graph nfa) v)
    modifySTRef vertexMapRef (Map.insert v' v)
    when (v == startState nfa) $ writeSTRef startStateRef (Just v')
    when (v `Set.member` finalStates nfa) $
      modifySTRef finalStatesRef (Set.insert v')

  forM_ (edges (graph nfa)) $ \e -> do
    addLabeledEdge g' (edgeSource e) (edgeDest e) (g (fromJust (edgeLabel (graph nfa) e)))

  mkNFA
    <$> freeze g'
    <*> (fromJust <$> readSTRef startStateRef)
    <*> readSTRef finalStatesRef

-- | One round of string generation.
generate1 :: (Monoid m, Ord m, Graph g)
          => LabeledGraph g nl m
          -- ^ The NFAraph
          -> Set (Vertex, m)
          -- ^ set of discovered (Vertex, m) pairs thus far
          -> Seq (Vertex, m)
          -- ^ (Vertex, m) pairs to generate from
          -> (Set (Vertex, m), Seq (Vertex, m))
          -- ^ The new set (with the newly-discovered pairs), plus the new pairs
          -- that we need to generate from next
generate1 _ seen Seq.Empty = (seen, Seq.Empty)
generate1 g seen ((v, s) Seq.:<| from) =
  let new =  [ (d, s <> l) | e <- outEdges g v
                           , let d = edgeDest e
                           , let Just l = edgeLabel g e ]
  in ( seen `Set.union` Set.fromList new
     , from Seq.>< [ pair | pair <- Seq.fromList new, (not . (`elem` seen)) pair ]
     )

-- | An infinite list generated by 'iterate'ing the 'generate1' function.
generate' :: (Monoid m, Ord m, Graph g)
          => LabeledGraph g nl m
          -- ^ The NFA nl graph
          -> Set (Vertex, m)
          -- ^ set of discovered (Vertex, string) pairs thus far
          -> Seq (Vertex, m)
          -- ^ (Vertex, string) pairs to generate from
          -> [(Set (Vertex, m), Seq (Vertex, m))]
          -- ^ The new set (with the newly-discovered pairs), plus the new pairs
          -- that we need to generate from next
generate' g seen from = iterate (uncurry (generate1 g)) (seen, from)

-- | Generate strings from an NFA nl. The 'Int' is the number of times to walk the
-- NFA nl graph. If there are multiple final states that accept the same string,
-- that string will appear (correspondingly) multiple times in this list.
generate :: (Monoid m, Ord m)
         => Int
         -- ^ How many rounds of generation to perform
         -> NFA nl m
         -> [m]
generate n nfa =
  [ s | let (pairs, _) = generate' (graph nfa) (Set.singleton (startState nfa, mempty)) (Seq.singleton (startState nfa, mempty)) !! n
      , (q, s) <- Set.toList pairs
      , q `Set.member` finalStates nfa
      ]

-- | Generate the entire list of strings from an NFA. This is an exhaustive
-- breadth-first search that only stops when it cannot generate new strings;
-- therefore if the NFA has cycles, it may never terminate.
generateAll :: (Monoid m, Ord m) => NFA nl m -> [m]
generateAll nfa =
  [ s | let (pairs, _) = term $ generate' (graph nfa) (Set.singleton (startState nfa, mempty)) (Seq.singleton (startState nfa, mempty))
      , (q, s) <- Set.toList pairs
      , q `Set.member` finalStates nfa
      ]

  where term (a:a':as) | a == a' = a
                       | otherwise = term (a':as)
        term _ = error "generateAll"

-- | Given two NFA nls that operate on a common subset, produce an NFA nl whose
-- alphabet is the union of the two alphabets, and whose language is exactly the
-- strings that, when restricted to either of the two alphabets, are exactly the
-- corresponding languages.
join :: forall g nl a . (Monoid nl, Ord a, g ~ Digraph) => NFA nl a -> NFA nl a -> NFA nl a
join nfa1 nfa2 = runST $ do
  let g1 = graph nfa1
      g2 = graph nfa2
      s1 = startState nfa1
      s2 = startState nfa2
      finals1 = finalStates nfa1
      finals2 = finalStates nfa2

  g <- newLabeledGraph newMBiDigraph
  startRef <- newSTRef Nothing
  finalsRef <- newSTRef Set.empty

  -- map from (g1, g2) vertex pairs to g vertices.
  vertexMapRef <- newSTRef Map.empty

  -- First, add all the vertices and build up the vertex map.
  forM_ (vertices g1) $ \v1 -> do
    forM_ (vertices g2) $ \v2 -> do
      let l = fromJust (vertexLabel g1 v1) <>
              fromJust (vertexLabel g2 v2)
      v <- addLabeledVertex g l
      -- Add new vertex to vertex map
      modifySTRef vertexMapRef (Map.insert (v1, v2) v)
      -- If both vertices are the start state, then the new vertex is the joined
      -- start state
      when (v1 == s1 && v2 == s2) $
        writeSTRef startRef (Just v)
      -- If both vertices are final states, then the new vertex is one of the
      -- joined final states
      when (v1 `Set.member` finals1 && v2 `Set.member` finals2) $
        modifySTRef finalsRef (Set.insert v)

  vertexMap <- readSTRef vertexMapRef

  let sharedSymbols = alphabet nfa1 `Set.intersection` alphabet nfa2

  -- Create a map from all shared labels to corresponding edges in g2.
  let g2LeftEdgeMap = foldr p Map.empty (edges g2)
      p e m = let a = fromJust (edgeLabel g2 e)
              in if a `Set.member` sharedSymbols
                 then Map.insertWith Set.union a (Set.singleton e) m
                 else m

  forM_ (edges g1) $ \e -> do
    let a = fromJust (edgeLabel g1 e)
    case a `Set.member` sharedSymbols of
      False -> forM_ (vertices g2) $ \v2 -> do
        let src = vertexMap Map.! (edgeSource e, v2)
            dst = vertexMap Map.! (edgeDest e, v2)
        addLabeledEdge g src dst a
      True -> case Map.lookup a g2LeftEdgeMap of
        -- Look up the g2 edges with the same label, and add the corresponding
        -- vertices.
        Nothing -> return ()
        Just es -> forM_ es $ \e' -> do
          let src = vertexMap Map.! (edgeSource e, edgeSource e')
              dst = vertexMap Map.! (edgeDest e, edgeDest e')
          addLabeledEdge g src dst a

  forM_ (edges g2) $ \e -> do
    let a = fromJust (edgeLabel g2 e)
    case a `Set.member` sharedSymbols of
      True -> return ()
      False  -> forM_ (vertices g1) $ \v1 -> do
        let src = vertexMap Map.! (v1, edgeSource e)
            dst = vertexMap Map.! (v1, edgeDest e)
        addLabeledEdge g src dst a

  start <- readSTRef startRef
  finals <- readSTRef finalsRef

  (g'Mut, reduceMap) <- reduceGraph (fromJust start) finals g
  g' <- freeze g'Mut
  let start' = fromJust (Map.lookup (fromJust start) reduceMap)
      finals' = Set.fromList (catMaybes (flip Map.lookup reduceMap <$> Set.toList finals))
  return $ mkNFA g' start' finals'
