{-# LANGUAGE MonadComprehensions #-}
{-# LANGUAGE TypeFamilies #-}

-- | A module providing a simple implementation of NFAs in terms of @haggle@
-- graphs.
module Regulate.NFA
   ( NFA(..)
   , generate
   , generate'
   , generate1
   ) where

import Data.Graph.Haggle
import Data.Sequence (Seq)
import qualified Data.Sequence as Seq
import Data.Set (Set)
import qualified Data.Set as Set

-- | An @NFA@ over an alphabet @sigma@ is just a directed graph with labels from
-- @sigma@, along with a designated start state and a set of designated final
-- states.
--
-- The vertices of the graph correspond to the states, and the labeled edges are
-- transitions.
data NFA sigma = NFA { graph :: EdgeLabeledGraph Digraph sigma
                     , startState :: Vertex
                     , finalStates :: Set Vertex
                     }

-- | One round of string generation.
generate1 :: Ord sigma
          => EdgeLabeledGraph Digraph sigma
          -- ^ The NFA graph
          -> Set (Vertex, Seq sigma)
          -- ^ set of discovered (Vertex, String) pairs thus far
          -> Seq (Vertex, Seq sigma)
          -- ^ (Vertex, String) pairs to generate from
          -> (Set (Vertex, Seq sigma), Seq (Vertex, Seq sigma))
          -- ^ The new set (with the newly-discovered pairs), plus the new pairs
          -- that we need to generate from next
generate1 _ seen Seq.Empty = (seen, Seq.Empty)
generate1 g seen ((v, s) Seq.:<| from) =
  let new =  [ (d, s Seq.:|> l) | e <- outEdges g v
                               , let d = edgeDest e
                               , let Just l = edgeLabel g e ]
  in ( seen `Set.union` Set.fromList new
     , from Seq.>< [ pair | pair <- Seq.fromList new, (not . (`elem` seen)) pair ]
     )

-- | An infinite list generated by 'iterate'ing the 'generate1' function.
generate' :: Ord sigma
          => EdgeLabeledGraph Digraph sigma
          -- ^ The NFA graph
          -> Set (Vertex, Seq sigma)
          -- ^ set of discovered (Vertex, string) pairs thus far
          -> Seq (Vertex, Seq sigma)
          -- ^ (Vertex, string) pairs to generate from
          -> [(Set (Vertex, Seq sigma), Seq (Vertex, Seq sigma))]
          -- ^ The new set (with the newly-discovered pairs), plus the new pairs
          -- that we need to generate from next
generate' g seen from = iterate (uncurry (generate1 g)) (seen, from)

-- | Generate strings from an NFA. The 'Int' is the number of times to walk the
-- NFA graph. If there are multiple final states that accept the same string,
-- that string will appear (correspondingly) multiple times in this list.
generate :: Ord sigma
         => Int
         -- ^ How many rounds of generation to perform
         -> NFA sigma
         -> [Seq sigma]
generate n nfa =
  [ s | let (pairs, _) = generate' (graph nfa) Set.empty (Seq.singleton (startState nfa, Seq.Empty)) !! n
      , (q, s) <- Set.toList pairs
      , q `Set.member` finalStates nfa
      ]
